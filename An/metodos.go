// Code generated by PABLO. DO NOT EDIT.

package An

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"
)

// LAS FUNCIONES DE ESTE ARCHIVO ESTAN COMPARTIDAS PORQUE PERTENECEN AL MISMO PACKAGE , siempre deben de iniciar con MAYUSCULA el nombre del metodo para ser exportado

// QuitarComillas: igual para la declaracion de variables MAYUSCULA AL INICIO para usar ne otras partes

func init() {
	// es una funcion especial que permite iniciazar variables o estructuras
}

//quita \* de continuacion de linea
func QuitarSimboloNextLine(cadena string) string {
	salida := ""
	for i := 0; i < len(cadena); i++ {
		if (i != len(cadena)-2) && (i != len(cadena)-1) {
			salida += string(cadena[i])
		}
	}
	return salida
}

// QuitarComillas lo que hace es quitar comillas xd
func QuitarComillas(ruta string) string {

	salida := ""
	if ruta[0] == '"' {
		//fmt.Println("tiene comillas")
		for i := 0; i < len(ruta); i++ {
			if i != 0 && (i != len(ruta)-1) {
				salida += string(ruta[i])
			}

		}
		//fmt.Println("SALIDA: " + salida)
	} else {
		salida = ruta
	}
	return salida
}

func verificarRuta(ruta string) {
	rutas := strings.Split(ruta, "/")

	var temporal string = ""
	if ruta[len(ruta)-1] != '/' {
		i := 0
		for i < len(rutas) {
			temporal += rutas[i] + "/"
			CrearDirectorio_si_no_exist(temporal)
			//mkdisk-SIze->1-path->/home/pablo/Escritorio/carpetae/hola/-name->prub.dsk-unit->K
			i++
		}
	} else {
		i := 0
		for i < len(rutas) {
			if i != (len(rutas) - 1) {
				temporal += rutas[i] + "/"
				CrearDirectorio_si_no_exist(temporal)
			}
			i++
		}
	}
}
func CrearDisco(numero string, ruta string, nombre string, K_o_M string) {
	ruta = QuitarComillas(ruta)
	tamanio, _ := strconv.ParseInt(numero, 10, 64)
	//	fmt.Printf("%v\n", tamanio)
	verificarRuta(ruta)
	size := int64(0)
	if K_o_M == "K" || K_o_M == "k" {
		size = int64(tamanio * 1024)
	} else { // SINO SON MEGABYTES
		size = int64(tamanio * 1024 * 1024)
	}
	rutaCompleta := ruta + nombre
	fichero, err := os.Create(rutaCompleta)
	defer fichero.Close()
	if err != nil {
		log.Fatal("fallo creando el archivo de salida")
	} else {
		fmt.Println("Disco creado Correctamente")
	}
	otro := int64(0) // asignando el cero
	direccion_otro := &otro
	var binario_ bytes.Buffer
	binary.Write(&binario_, binary.BigEndian, direccion_otro) // SE ESCRIBE UN CERO AL INICIO DEL ARCHIVO
	escribirBinariamente(fichero, binario_.Bytes())
	fichero.Seek(size-1, 0) // posicionarse en la pos 0

	var bin2_ bytes.Buffer // se escribe un cero al final del archivo
	binary.Write(&bin2_, binary.BigEndian, direccion_otro)
	escribirBinariamente(fichero, bin2_.Bytes())
	/*
		METIENDO EL STRUCT AL DISCO
	*/
	fichero.Seek(0, 0) // POS AL INICIO DEL ARCHIVO
	// SEREALIZACION DEL STRUCT , escribir al inicio del archivo el struct
	disco := tipoMbr{tamanio: 0, fecha: time.Now()}
	dirMemory_disco := &disco

	var bin3_ bytes.Buffer
	binary.Write(&bin3_, binary.BigEndian, dirMemory_disco)
	escribirBinariamente(fichero, bin3_.Bytes())

	// limpiar variables
	Name_ = ""
	Path_ = ""
	Size_ = ""
	Unit_m_ = "M"

}

func escribirBinariamente(fichero *os.File, bytes []byte) {
	_, erro := fichero.Write(bytes)
	if erro != nil {
		log.Fatal(erro)
	}
}

// elimina un disco duro o archivo
func EliminarDisco(ruta_absoluta string) {
	ruta_absoluta = QuitarComillas(ruta_absoluta)
	fmt.Println("Â¿ESTA SEGURO DE QUERER ELIMINAR ESTE DISCO? ")
	fmt.Print("Presione 1 para confirmar, dsino presione 0")
	var decision int
	fmt.Scanln(&decision)
	if decision == 1 {
		erro := os.Remove(ruta_absoluta)
		if erro == nil {
			fmt.Println("Disco eliminado...")
		} else {
			fmt.Printf("ERROR , NO SE PUEDO ELIMINAR EL DISCO: %v\n", erro)
		}
	}
}

// crea un direcctorio si no encuentra la ruta
func CrearDirectorio_si_no_exist(dir__ string) {

	if _, err := os.Stat(dir__); os.IsNotExist(err) {

		err = os.Mkdir(dir__, 0755)
		fmt.Println("Crea la carpeta:  " + dir__)
		if err != nil {
			panic(err)
		}
	}

}

type tipoMbr struct {
	tamanio       int64
	fecha         time.Time
	diskSignature int64
	particiones   [4]Particion
}

type Particion struct {
	status byte
	fit    byte // son char de GOLANG
	inicio int64
	size   byte
	nombre [16]byte
	tipo   byte
}

type Extended_B_R struct {
	status byte
	fit    byte // son char de GOLANG
	inicio int64
	size   byte
	nombre [16]byte
	next   int64
}
